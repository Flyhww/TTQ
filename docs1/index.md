## Vue系列

### 说说你对Vue的理解？

#### 一、Vue是什么

Vue是一套用于构建用户界面的**渐进式框架**。

#### 二、Vue核心特性

##### 数据驱动(MVVM)

MVVM表示的是Model-View-ViewModel

- Model：模型层，负责处理业务逻辑以及和服务端进行交互
- View：视图层，负责将数据模型转化为UI展示出来，可以简单理解为HTML页面
- ViewModel：视图模型层，用来连接Model和View，是Model和View之间的通信桥梁

##### 组件化

什么是组件化一句话来说就是把图形、非图形的合种逻辑均抽象为一个统一的概念（组件）来实现开发的模式，在Vue中的每一个.Vue文件都可以视为一个组件

组件化的优势：

- 降低整个系统的耦合度
- 调试方便
- 提高可维护性

##### 指令系统

指令是带有v-前缀的特殊属性

作用：当表达式的值改变时，将其产生的连带影响，响应式的作用于DOM

常用的指令：

- 条件渲染 v-if
- 列表渲染 v-for
- 属性绑定 v-bind
- 事件绑定 v-on
- 双向数据绑定 v-model

#### 三、Vue跟传统开发的区别

- Vue所有的界面事件，都只是操作数据的，Jquery操作DOM
- Vue所有数据的变动，都是根据数据自动绑定出来的，Jquery操作DOM

#### 四、Vue和React对比

##### 相同点

- 都有组件化思想
- 都支持服务端渲染
- 都有Virtual DOM（虚拟DOM）
- 数据驱动视图
- 都有支持Native的方案： Vue：weex 、React： native
- 都有自己的构建工具：Vue：vue-cli 、React：Create React App

##### 区别

- 数据流向不同。React从诞生开始就推崇单向数据流，而Vue是双向数据流
- 数据变化的实现原理不同。React使用的是不可变数据，而Vue使用的是可变数据
- 组件化通信的不同。React中通过使用回调函数来进行通信，而Vue中子组件向父组件传递方式有两种：事件和回调函数
- diff算法不同。React主要使用diff队列保存需要更新哪些DOM，得到patch树，再统一操作批量更新DOM。Vue使用双向指针，边对比，边更新DOM



### SPA（单页应用）首屏加载速度慢怎么解决？

#### 一、什么是首屏加载

首屏时间：指的是浏览器从相应用户输入的网址地址，到首屏内容渲染完成时间，此时整个网页不一定要全部渲染，但需要展示当前视图需要的内容

#### 二、加载慢的原因

- 网络延时问题
- 资源文件体积过大
- 资源是否重复发送请求加载
- 加载脚本的时候，渲染内容堵塞了

#### 三、解决方案

- 减小入口文件体积
- 静态资源本地缓存
- UI框架按需加载
- 图片资源压缩
- 组件重复打包
- 开启GZip压缩
- 使用SSR（服务端渲染）



### 什么是Vuex

- Vuex是专门为Vuex.js设计的状态管理库
- Vuex采用集中式的方式储存需要共享的状态
- Vuex的作用是进行状态管理，解决复杂组件通信，数据共享
- Vuex集成到了devtools中，提供了time-travel时光旅行历史回滚功能

#### 什么情况下使用Vuex

- 非必要情况下不使用Vuex
- 大型的单页应用程序
  - 多个视图依赖于同一状态
  - 来自不同视图的行为需要变更同一状态

#### Vuex的核心概念

- State: 数据存储
- Mutation:   更改Store状态的唯一方法，并且这个过程是同步的 ，通过 commit触发
- Aciton:  处理异步任务，通过dispatch触发
- Getter：   用于对 Store 中的数据进行加工处理形成新的数据 ，类似 Vue 的 computed属性 
- Module:  将store分割成模块,每个模块都有state、mutation、action、getter、甚至嵌套子模块 

#### Vuex的严格模式

 **不要在发布环境下启用严格模式**！严格模式会深度监测状态树来检测不合规的状态变更——请确保在发布环境下关闭严格模式，以避免性能损失。



## 小程序系列

### 如何提高微信小程序的应用速度？

**小程序启动加载性能：**

- 控制代码包的大小
- 分包加载
- 首屏体验（预请求，利用缓存，避免白屏，及时反馈）

**小程序渲染性能：**

- 避免不当的使用setData
- 使用自定义组件





## JavaScript系列

### 闭包

- 闭包（closure)：函数和其周围的状态（语法环境）的引用捆绑在一起形成闭包。

- 可以在另一个作用域中调用一个函数的内部函数并访问到该函数的作用域中的成员
- 闭包的本质：函数在执行的时候会放到一个执行栈上当函数执行完毕之后会从执行栈移除，但是堆上的作用域成员因为被外部引用不能释放，因此内部函数依然可以访问外部函数的成员
- 闭包的好处：延长了外部函数的作用范围

### 柯里化（currying)

- 当一个函数有多个参数的时候先传递一部分参数调用它（这部分参数以后永远不变）
- 然后返回一个新的函数接收剩余的参数，返回结果

#### lodash中的柯里化函数

- 功能：创建一个函数，该函数接收一个或多个func的函数，如果func所需要的参数都被提供则执行func并返回执行的结果。否则继续返回函数并等待接收剩余的参数。
- 参数：需要柯里化的函数
- 返回值：柯里化后的函数



## HTTP系列