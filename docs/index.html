<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="generator" content="VuePress 2.0.0-beta.49">
    <style>
      :root {
        --c-bg: #fff;
      }
      html.dark {
        --c-bg: #22272e;
      }
      html, body {
        background-color: var(--c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem('vuepress-color-scheme');
			const systemDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
			if (userMode === 'dark' || (userMode !== 'light' && systemDarkMode)) {
				document.documentElement.classList.toggle('dark', true);
			}
    </script>
    <link rel="icon" href="/images/logo.png"><title>Hello 甜甜圈~</title><meta name="description" content="这是我的第一个 VuePress 站点">
    <link rel="modulepreload" href="/TTQ/assets/app.2cebdad9.js"><link rel="modulepreload" href="/TTQ/assets/index.html.335024c3.js"><link rel="modulepreload" href="/TTQ/assets/index.html.29e8e4a9.js"><link rel="prefetch" href="/TTQ/assets/index-2.html.0e02e2be.js"><link rel="prefetch" href="/TTQ/assets/ms.html.6744c24a.js"><link rel="prefetch" href="/TTQ/assets/404.html.da202eb3.js"><link rel="prefetch" href="/TTQ/assets/index-2.html.d61d8930.js"><link rel="prefetch" href="/TTQ/assets/ms.html.ef319358.js"><link rel="prefetch" href="/TTQ/assets/404.html.f5e881a0.js"><link rel="prefetch" href="/TTQ/assets/404.6d4b6458.js"><link rel="prefetch" href="/TTQ/assets/Layout.07d7679e.js">
    <link rel="stylesheet" href="/TTQ/assets/style.ea4b05d1.css">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container"><!--[--><header class="navbar"><div class="toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a aria-current="page" href="/TTQ/" class="router-link-active router-link-exact-active"><!----><span class="site-name">Hello 甜甜圈~</span></a></span><div class="navbar-items-wrapper" style=""><!--[--><!--]--><!----><!--[--><!--]--><button class="toggle-color-mode-button" title="toggle color mode"><svg style="" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg style="display:none;" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><form class="search-box" role="search"><input type="search" autocomplete="off" spellcheck="false" value><!----></form></div></header><!--]--><div class="sidebar-mask"></div><!--[--><aside class="sidebar"><!----><!--[--><!--]--><ul class="sidebar-items"><!--[--><li><p tabindex="0" class="sidebar-item sidebar-heading"> <!----></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/TTQ/#vue系列" class="router-link-active router-link-exact-active sidebar-item" aria-label="Vue系列"><!--[--><!--]--> Vue系列 <!--[--><!--]--></a><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/TTQ/#说说你对vue的理解" class="router-link-active router-link-exact-active sidebar-item" aria-label="说说你对Vue的理解？"><!--[--><!--]--> 说说你对Vue的理解？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/TTQ/#spa-单页应用-首屏加载速度慢怎么解决" class="router-link-active router-link-exact-active sidebar-item" aria-label="SPA（单页应用）首屏加载速度慢怎么解决？"><!--[--><!--]--> SPA（单页应用）首屏加载速度慢怎么解决？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/TTQ/#vue-router" class="router-link-active router-link-exact-active sidebar-item" aria-label="Vue Router"><!--[--><!--]--> Vue Router <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/TTQ/#什么是vuex" class="router-link-active router-link-exact-active sidebar-item" aria-label="什么是Vuex"><!--[--><!--]--> 什么是Vuex <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/TTQ/#javascript系列" class="router-link-active router-link-exact-active sidebar-item" aria-label="JavaScript系列"><!--[--><!--]--> JavaScript系列 <!--[--><!--]--></a><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/TTQ/#闭包" class="router-link-active router-link-exact-active sidebar-item" aria-label="闭包"><!--[--><!--]--> 闭包 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/TTQ/#作用域" class="router-link-active router-link-exact-active sidebar-item" aria-label="作用域"><!--[--><!--]--> 作用域 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/TTQ/#柯里化-currying" class="router-link-active router-link-exact-active sidebar-item" aria-label="柯里化（currying)"><!--[--><!--]--> 柯里化（currying) <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/TTQ/#原型和原型链" class="router-link-active router-link-exact-active sidebar-item" aria-label="原型和原型链"><!--[--><!--]--> 原型和原型链 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/TTQ/#深拷贝和浅拷贝的区别" class="router-link-active router-link-exact-active sidebar-item" aria-label="深拷贝和浅拷贝的区别？"><!--[--><!--]--> 深拷贝和浅拷贝的区别？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/TTQ/#数组方法" class="router-link-active router-link-exact-active sidebar-item" aria-label="数组方法"><!--[--><!--]--> 数组方法 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/TTQ/#说说new操作符具体干了什么" class="router-link-active router-link-exact-active sidebar-item" aria-label="说说New操作符具体干了什么？"><!--[--><!--]--> 说说New操作符具体干了什么？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/TTQ/#bind、call、apply的区别" class="router-link-active router-link-exact-active sidebar-item" aria-label="bind、call、apply的区别？"><!--[--><!--]--> bind、call、apply的区别？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/TTQ/#浏览器存储方式及区别" class="router-link-active router-link-exact-active sidebar-item" aria-label="浏览器存储方式及区别"><!--[--><!--]--> 浏览器存储方式及区别 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/TTQ/#小程序系列" class="router-link-active router-link-exact-active sidebar-item" aria-label="小程序系列"><!--[--><!--]--> 小程序系列 <!--[--><!--]--></a><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/TTQ/#如何提高微信小程序的应用速度" class="router-link-active router-link-exact-active sidebar-item" aria-label="如何提高微信小程序的应用速度？"><!--[--><!--]--> 如何提高微信小程序的应用速度？ <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/TTQ/#uni-app系列" class="router-link-active router-link-exact-active sidebar-item" aria-label="uni-app系列"><!--[--><!--]--> uni-app系列 <!--[--><!--]--></a><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/TTQ/#uni-app升级app" class="router-link-active router-link-exact-active sidebar-item" aria-label="uni-app升级APP"><!--[--><!--]--> uni-app升级APP <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/TTQ/#http系列" class="router-link-active router-link-exact-active sidebar-item" aria-label="HTTP系列"><!--[--><!--]--> HTTP系列 <!--[--><!--]--></a><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/TTQ/#在地址栏输入url敲下回车会发生什么" class="router-link-active router-link-exact-active sidebar-item" aria-label="在地址栏输入URL敲下回车会发生什么？"><!--[--><!--]--> 在地址栏输入URL敲下回车会发生什么？ <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/TTQ/#webpack系列" class="router-link-active router-link-exact-active sidebar-item" aria-label="webpack系列"><!--[--><!--]--> webpack系列 <!--[--><!--]--></a><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/TTQ/#webpack的构建流程" class="router-link-active router-link-exact-active sidebar-item" aria-label="webpack的构建流程"><!--[--><!--]--> webpack的构建流程 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/TTQ/#css系列" class="router-link-active router-link-exact-active sidebar-item" aria-label="CSS系列"><!--[--><!--]--> CSS系列 <!--[--><!--]--></a><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/TTQ/#css预编译语言有哪些-区别是什么" class="router-link-active router-link-exact-active sidebar-item" aria-label="CSS预编译语言有哪些？区别是什么？"><!--[--><!--]--> CSS预编译语言有哪些？区别是什么？ <!--[--><!--]--></a><!----></li><!--]--></ul></li><!--]--></ul></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="page"><!--[--><!--]--><div class="theme-default-content"><!--[--><!--]--><div><h2 id="vue系列" tabindex="-1"><a class="header-anchor" href="#vue系列" aria-hidden="true">#</a> Vue系列</h2><h3 id="说说你对vue的理解" tabindex="-1"><a class="header-anchor" href="#说说你对vue的理解" aria-hidden="true">#</a> 说说你对Vue的理解？</h3><h4 id="一、vue是什么" tabindex="-1"><a class="header-anchor" href="#一、vue是什么" aria-hidden="true">#</a> 一、Vue是什么</h4><p>Vue是一套用于构建用户界面的<strong>渐进式框架</strong>。</p><h4 id="二、vue核心特性" tabindex="-1"><a class="header-anchor" href="#二、vue核心特性" aria-hidden="true">#</a> 二、Vue核心特性</h4><h5 id="数据驱动-mvvm" tabindex="-1"><a class="header-anchor" href="#数据驱动-mvvm" aria-hidden="true">#</a> 数据驱动(MVVM)</h5><p>MVVM表示的是Model-View-ViewModel</p><ul><li>Model：模型层，负责处理业务逻辑以及和服务端进行交互</li><li>View：视图层，负责将数据模型转化为UI展示出来，可以简单理解为HTML页面</li><li>ViewModel：视图模型层，用来连接Model和View，是Model和View之间的通信桥梁</li></ul><h5 id="组件化" tabindex="-1"><a class="header-anchor" href="#组件化" aria-hidden="true">#</a> 组件化</h5><p>什么是组件化一句话来说就是把图形、非图形的合种逻辑均抽象为一个统一的概念（组件）来实现开发的模式，在Vue中的每一个.Vue文件都可以视为一个组件</p><p>组件化的优势：</p><ul><li>降低整个系统的耦合度</li><li>调试方便</li><li>提高可维护性</li></ul><h5 id="指令系统" tabindex="-1"><a class="header-anchor" href="#指令系统" aria-hidden="true">#</a> 指令系统</h5><p>指令是带有v-前缀的特殊属性</p><p>作用：当表达式的值改变时，将其产生的连带影响，响应式的作用于DOM</p><p>常用的指令：</p><ul><li>条件渲染 v-if</li><li>列表渲染 v-for</li><li>属性绑定 v-bind</li><li>事件绑定 v-on</li><li>双向数据绑定 v-model</li></ul><h4 id="三、响应式的核心原理" tabindex="-1"><a class="header-anchor" href="#三、响应式的核心原理" aria-hidden="true">#</a> 三、响应式的核心原理</h4><p><strong>vue2.0X</strong></p><ul><li>当你把一个普通的JavaScript对象传入Vue实例作为<code>data</code>选项，Vue将遍历此对象所有的<code>property</code>，并使用<code>Object.defineProperty</code>把这些<code>property</code>全部转为<code>getter/setter</code></li><li><code>Object.defineProperty</code>是ES5中一个无法shim的特性，这也就是Vue不支持IE8以及更低版本浏览器的原</li></ul><p><strong>vue3.0X</strong></p><ul><li>当我们从一个组件的 <code>data</code> 函数中返回一个普通的 JavaScript 对象时，Vue 会将该对象包裹在一个带有 <code>get</code> 和 <code>set</code> 处理程序的 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy" target="_blank" rel="noopener noreferrer">Proxy<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a> 中</li><li><code>Proxy</code> 是在 ES6 中引入的，它使 Vue 3 避免了 Vue 早期版本中存在的一些响应性问题。</li><li><code>Proxy</code> IE 不支持， 性能由浏览器优化</li></ul><h4 id="四、vue跟传统开发的区别" tabindex="-1"><a class="header-anchor" href="#四、vue跟传统开发的区别" aria-hidden="true">#</a> 四、Vue跟传统开发的区别</h4><ul><li>Vue所有的界面事件，都只是操作数据的，Jquery操作DOM</li><li>Vue所有数据的变动，都是根据数据自动绑定出来的，Jquery操作DOM</li></ul><h4 id="五、vue和react对比" tabindex="-1"><a class="header-anchor" href="#五、vue和react对比" aria-hidden="true">#</a> 五、Vue和React对比</h4><h5 id="相同点" tabindex="-1"><a class="header-anchor" href="#相同点" aria-hidden="true">#</a> 相同点</h5><ul><li>都有组件化思想</li><li>都支持服务端渲染</li><li>都有Virtual DOM（虚拟DOM）</li><li>数据驱动视图</li><li>都有支持Native的方案： Vue：weex 、React： native</li><li>都有自己的构建工具：Vue：vue-cli 、React：Create React App</li></ul><h5 id="区别" tabindex="-1"><a class="header-anchor" href="#区别" aria-hidden="true">#</a> 区别</h5><ul><li>数据流向不同。React从诞生开始就推崇单向数据流，而Vue是双向数据流</li><li>数据变化的实现原理不同。React使用的是不可变数据，而Vue使用的是可变数据</li><li>组件化通信的不同。React中通过使用回调函数来进行通信，而Vue中子组件向父组件传递方式有两种：事件和回调函数</li><li>diff算法不同。React主要使用diff队列保存需要更新哪些DOM，得到patch树，再统一操作批量更新DOM。Vue使用双向指针，边对比，边更新DOM</li></ul><h3 id="spa-单页应用-首屏加载速度慢怎么解决" tabindex="-1"><a class="header-anchor" href="#spa-单页应用-首屏加载速度慢怎么解决" aria-hidden="true">#</a> SPA（单页应用）首屏加载速度慢怎么解决？</h3><h4 id="一、什么是首屏加载" tabindex="-1"><a class="header-anchor" href="#一、什么是首屏加载" aria-hidden="true">#</a> 一、什么是首屏加载</h4><p>首屏时间：指的是浏览器从相应用户输入的网址地址，到首屏内容渲染完成时间，此时整个网页不一定要全部渲染，但需要展示当前视图需要的内容</p><h4 id="二、加载慢的原因" tabindex="-1"><a class="header-anchor" href="#二、加载慢的原因" aria-hidden="true">#</a> 二、加载慢的原因</h4><ul><li>网络延时问题</li><li>资源文件体积过大</li><li>资源是否重复发送请求加载</li><li>加载脚本的时候，渲染内容堵塞了</li></ul><h4 id="三、解决方案" tabindex="-1"><a class="header-anchor" href="#三、解决方案" aria-hidden="true">#</a> 三、解决方案</h4><ul><li>减小入口文件体积</li><li>静态资源本地缓存</li><li>UI框架按需加载</li><li>图片资源压缩</li><li>组件重复打包</li><li>开启GZip压缩</li><li>使用SSR（服务端渲染）</li></ul><h3 id="vue-router" tabindex="-1"><a class="header-anchor" href="#vue-router" aria-hidden="true">#</a> Vue Router</h3><ul><li>动态路由</li><li>嵌套路由</li><li>编程式导航</li></ul><h4 id="模式" tabindex="-1"><a class="header-anchor" href="#模式" aria-hidden="true">#</a> 模式：</h4><ul><li>hash：URL中#号后面的内容作为路径地址，基于锚点和onHashChange事件</li><li>history：基于History API，history.pushState() history.replaceState() ，History需要服务器的支持</li></ul><h3 id="什么是vuex" tabindex="-1"><a class="header-anchor" href="#什么是vuex" aria-hidden="true">#</a> 什么是Vuex</h3><ul><li>Vuex是专门为Vuex.js设计的状态管理库</li><li>Vuex采用集中式的方式储存需要共享的状态</li><li>Vuex的作用是进行状态管理，解决复杂组件通信，数据共享</li><li>Vuex集成到了devtools中，提供了time-travel时光旅行历史回滚功能</li></ul><h4 id="什么情况下使用vuex" tabindex="-1"><a class="header-anchor" href="#什么情况下使用vuex" aria-hidden="true">#</a> 什么情况下使用Vuex</h4><ul><li>非必要情况下不使用Vuex</li><li>大型的单页应用程序 <ul><li>多个视图依赖于同一状态</li><li>来自不同视图的行为需要变更同一状态</li></ul></li></ul><h4 id="vuex的核心概念" tabindex="-1"><a class="header-anchor" href="#vuex的核心概念" aria-hidden="true">#</a> Vuex的核心概念</h4><ul><li>State: 数据存储</li><li>Mutation: 更改Store状态的唯一方法，并且这个过程是同步的 ，通过 commit触发</li><li>Aciton: 处理异步任务，通过dispatch触发</li><li>Getter： 用于对 Store 中的数据进行加工处理形成新的数据 ，类似 Vue 的 computed属性</li><li>Module: 将store分割成模块,每个模块都有state、mutation、action、getter、甚至嵌套子模块</li></ul><h4 id="vuex的严格模式" tabindex="-1"><a class="header-anchor" href="#vuex的严格模式" aria-hidden="true">#</a> Vuex的严格模式</h4><p><strong>不要在发布环境下启用严格模式</strong>！严格模式会深度监测状态树来检测不合规的状态变更——请确保在发布环境下关闭严格模式，以避免性能损失。</p><h2 id="javascript系列" tabindex="-1"><a class="header-anchor" href="#javascript系列" aria-hidden="true">#</a> JavaScript系列</h2><h3 id="闭包" tabindex="-1"><a class="header-anchor" href="#闭包" aria-hidden="true">#</a> 闭包</h3><ul><li><p>闭包（closure)：函数和其周围的状态（语法环境）的引用捆绑在一起形成闭包。</p></li><li><p>可以在另一个作用域中调用一个函数的内部函数并访问到该函数的作用域中的成员</p></li><li><p>闭包的本质：函数在执行的时候会放到一个执行栈上当函数执行完毕之后会从执行栈移除，但是堆上的作用域成员因为被外部引用不能释放，因此内部函数依然可以访问外部函数的成员</p></li><li><p>闭包的好处：延长了外部函数的作用范围</p></li></ul><h3 id="作用域" tabindex="-1"><a class="header-anchor" href="#作用域" aria-hidden="true">#</a> 作用域</h3><p>作用域：即变量和函数生效（能被访问）的区域或集合</p><p>作用域分为：</p><ul><li>全局作用域</li><li>函数作用域</li><li>块级作用域</li></ul><h3 id="柯里化-currying" tabindex="-1"><a class="header-anchor" href="#柯里化-currying" aria-hidden="true">#</a> 柯里化（currying)</h3><ul><li>当一个函数有多个参数的时候先传递一部分参数调用它（这部分参数以后永远不变）</li><li>然后返回一个新的函数接收剩余的参数，返回结果</li></ul><h4 id="lodash中的柯里化函数" tabindex="-1"><a class="header-anchor" href="#lodash中的柯里化函数" aria-hidden="true">#</a> lodash中的柯里化函数</h4><p>柯里化是把一个多参数函数转化成一个嵌套的一元函数的过程</p><ul><li>功能：创建一个函数，该函数接收一个或多个func的函数，如果func所需要的参数都被提供则执行func并返回执行的结果。否则继续返回函数并等待接收剩余的参数。</li><li>参数：需要柯里化的函数</li><li>返回值：柯里化后的函数</li></ul><h3 id="原型和原型链" tabindex="-1"><a class="header-anchor" href="#原型和原型链" aria-hidden="true">#</a> 原型和原型链</h3><p>怎么获取一个对象的原型？</p><p>Object.getPrototypeOf</p><p>原型：每个函数都有一个特殊的属性叫做原型<code>prototype</code></p><p>原项链：原型对象也可能拥有原型，并从中继承方法和属性，一层一层，以此类推。这种关系被称为原项链</p><p>总结：</p><ul><li>一切对象都是继承<code>Object</code>对象，<code>Object</code>对象直接继承根源对象null</li><li>一切函数对象（包括<code>Object</code>对象），都是继承<code>Function</code>对象</li><li><code>Function</code>对象的<code>__proto__</code>会指向自己的原型对象，最终还是继承<code>Object</code>对象</li></ul><h3 id="深拷贝和浅拷贝的区别" tabindex="-1"><a class="header-anchor" href="#深拷贝和浅拷贝的区别" aria-hidden="true">#</a> 深拷贝和浅拷贝的区别？</h3><h4 id="浅拷贝" tabindex="-1"><a class="header-anchor" href="#浅拷贝" aria-hidden="true">#</a> 浅拷贝</h4><p>如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是引用类型的地址</p><p>即浅拷贝是拷贝一层，深层次的引用类型则共享内存地址。</p><p><strong>实现方式：</strong></p><ul><li>Object.assign</li><li>concat</li><li>slice</li><li>拓展运算符（...）</li></ul><h4 id="深拷贝" tabindex="-1"><a class="header-anchor" href="#深拷贝" aria-hidden="true">#</a> 深拷贝</h4><p>深拷贝是开辟一个新的栈，两个对象属性完全想相同，但是对应两个不同的地址，修改一个对象的属性，不会改变另一个对象的属性。</p><p><strong>实现方式：</strong></p><ul><li>JSON.stringify()</li><li>_.clonrDeep</li><li>jQuery.extend</li><li>手写循环递归</li></ul><h3 id="数组方法" tabindex="-1"><a class="header-anchor" href="#数组方法" aria-hidden="true">#</a> 数组方法</h3><table><thead><tr><th>数组分类/标准</th><th>改变自身方法</th><th>不改变自身方法</th><th>遍历方法（不改变自身）</th></tr></thead><tbody><tr><td>ES5及以前</td><td>pop、push、reverse、shift、sort、splice、unshift</td><td>concat、join、slice、toString、toLocateString、indexOf、lastIndexOf</td><td>forEach、every、some、map、filiter、reduce、reduceRight</td></tr><tr><td>ES6/7/8</td><td>copyWithin、fill</td><td>includes、toSource</td><td>entries、find、findIndex、keys、values</td></tr></tbody></table><h3 id="说说new操作符具体干了什么" tabindex="-1"><a class="header-anchor" href="#说说new操作符具体干了什么" aria-hidden="true">#</a> 说说New操作符具体干了什么？</h3><ul><li>创建一个新的对象obj</li><li>将对象和构造函数通过原项链连接起来</li><li>将构造函数中的this绑定到新建的对象obj中</li><li>根据构造函数返回类型做判断，如果是原始值则被忽略，如果是返回对象，需要正常处理</li></ul><h3 id="bind、call、apply的区别" tabindex="-1"><a class="header-anchor" href="#bind、call、apply的区别" aria-hidden="true">#</a> bind、call、apply的区别？</h3><p>apply： <code>fn.apply(obj, [1, 2])</code></p><p>call：<code>fn.call(obj, 1, 2)</code></p><p>bind：<code>let bindFn = fn.bind(obj)； bindFn(1, 2)</code></p><p><strong>小结：</strong></p><ul><li>三者都是改变函数的this指向</li><li>三者第一个参数都是this要指向的对象，如果没有这个参数，或者参数为<code>undefind</code>或<code>null</code>，则默认指向全局window</li><li>三者都可以传参，但<code>apply</code>传入的是数组，而<code>call</code>是参数列表，并且<code>apply</code>和<code>call</code>是一次性传入参数，<code>bind</code>可以分为多次传入</li><li><code>bind</code>是返回绑定this之后的函数，<code>call</code>、<code>apply</code>则是立即执行</li></ul><h3 id="浏览器存储方式及区别" tabindex="-1"><a class="header-anchor" href="#浏览器存储方式及区别" aria-hidden="true">#</a> 浏览器存储方式及区别</h3><ul><li>cookie</li><li>sessionStorage</li><li>localStorage</li></ul><p><strong>区别</strong>：</p><ul><li>储存大小：<code>cookie</code>数据大小不能超过4K，<code>sessionStorage</code>和<code>loaclStorage</code>可以达到5或更大</li><li>存储时间：<code>localstorage</code>存储持久数据，浏览器关闭后数据不会丢失，除非主动删除数据；<code>sessionStorage</code>数据在当浏览器窗口关闭后自动删除；<code>cookie</code>在设置<code>cookie</code>过期时间前一直有效，即使窗口或浏览器关闭</li><li>数据与服务器之间的交互方式：<code>cookie</code>的数据会自动传递到服务器，服务器端也可以写<code>cookie</code>到客服端；<code>sessionStorage</code>和<code>localStarage</code>不会自动把数据发送服务器，仅在本地保存</li></ul><h2 id="小程序系列" tabindex="-1"><a class="header-anchor" href="#小程序系列" aria-hidden="true">#</a> 小程序系列</h2><h3 id="如何提高微信小程序的应用速度" tabindex="-1"><a class="header-anchor" href="#如何提高微信小程序的应用速度" aria-hidden="true">#</a> 如何提高微信小程序的应用速度？</h3><p><strong>小程序启动加载性能：</strong></p><ul><li>控制代码包的大小</li><li>分包加载</li><li>首屏体验（预请求，利用缓存，避免白屏，及时反馈）</li></ul><p><strong>小程序渲染性能：</strong></p><ul><li>避免不当的使用setData</li><li>使用自定义组件</li></ul><h2 id="uni-app系列" tabindex="-1"><a class="header-anchor" href="#uni-app系列" aria-hidden="true">#</a> uni-app系列</h2><h3 id="uni-app升级app" tabindex="-1"><a class="header-anchor" href="#uni-app升级app" aria-hidden="true">#</a> uni-app升级APP</h3><h4 id="三种方式" tabindex="-1"><a class="header-anchor" href="#三种方式" aria-hidden="true">#</a> 三种方式</h4><ul><li>apk包整包更新，需下载所有的文件包含权限模块依赖等，大小在20M+</li><li>wgt包应用资源更新，只更新自己写的代码，根据写代码的多少，大小在600K左右</li><li>wgtu应用资源差量升级，只更新自己写的代码改变的那一小部分，大小在100K左右</li></ul><h4 id="场景说明" tabindex="-1"><a class="header-anchor" href="#场景说明" aria-hidden="true">#</a> 场景说明</h4><ul><li>**.wgt打包（热更新）：**只有前端资源或者模块进行调整，整个APP结构不发生变化，那只需要更新这一部分资源，避免用户重新下载整个APP。通过HBuilderX打包.wgt包即可 <ol><li>代码修改完成</li><li>修改mainifest.json中的应用版本名称和应用版本号</li><li>发行</li><li>制作应用wgt包</li></ol></li><li><strong>.apk打包（整包更新）</strong>：App发生了非常大的改变，搭建框架发生改变，修改了APP模块配置，权限配置等这些mainifest.json里面的东西，那么就需要apk包整包升级，要求用户覆盖安装 <ol><li>代码修改完成</li><li>修改mainifest.json中的应用版本名称和应用版本号</li><li>发行</li><li>云打包</li></ol></li></ul><p>备注：安卓比较好实现热更新，uni-app ios暂时无法实现热更新，只能跳转Apple Store下载更新</p><h2 id="http系列" tabindex="-1"><a class="header-anchor" href="#http系列" aria-hidden="true">#</a> HTTP系列</h2><h3 id="在地址栏输入url敲下回车会发生什么" tabindex="-1"><a class="header-anchor" href="#在地址栏输入url敲下回车会发生什么" aria-hidden="true">#</a> 在地址栏输入URL敲下回车会发生什么？</h3><ul><li>URL解析</li><li>DNS查询</li><li>TCP连接，三次握手</li><li>发送HTTP请求</li><li>响应请求</li><li>页面渲染</li></ul><h2 id="webpack系列" tabindex="-1"><a class="header-anchor" href="#webpack系列" aria-hidden="true">#</a> webpack系列</h2><h3 id="webpack的构建流程" tabindex="-1"><a class="header-anchor" href="#webpack的构建流程" aria-hidden="true">#</a> webpack的构建流程</h3><ul><li>初始化流程：从配置文件中读取参数和变量，并初始化需要使用的插件和配置等执行环境所需要的参数</li><li>编译构建流程：从Entry出发，针对每个module串行调用对应的Loader去编译文件内容，再找到该module所依赖的module，递归的进行编译处理</li><li>输出流程：对编译后的module组合成Chunk，再将Chunk转换成文件，输出到文件系统dist目录</li></ul><h2 id="css系列" tabindex="-1"><a class="header-anchor" href="#css系列" aria-hidden="true">#</a> CSS系列</h2><h3 id="css预编译语言有哪些-区别是什么" tabindex="-1"><a class="header-anchor" href="#css预编译语言有哪些-区别是什么" aria-hidden="true">#</a> CSS预编译语言有哪些？区别是什么？</h3><ul><li>less</li><li>sass</li><li>stylus</li></ul><p>特性：</p><ul><li><p>变量：less用@符号声明变量；sass用$符号声明变量；stylus不需要符号声明变量</p><p>​ less和sass变量与值之间用:号；stylus变量与值之间用=号</p></li><li><p>作用域：sass不存在全局变量</p></li><li><p>混入（Mixins)：可以在Mixins中设置参数</p></li><li><p>嵌套： less需要用{}包裹，sass和stylus可以不需要{}包裹</p></li><li><p>模块化</p></li></ul></div><!--[--><!--]--></div><footer class="page-meta"><!----><div class="meta-item last-updated"><span class="meta-item-label">Last Updated: </span><!----></div><div class="meta-item contributors"><span class="meta-item-label">Contributors: </span><span class="meta-item-info"><!--[--><!--[--><span class="contributor" title="email: lihonmg@shuame.com">lihongwen</span><!----><!--]--><!--]--></span></div></footer><!----><!--[--><!--]--></main><!--]--></div><!----><!--]--></div>
    <script type="module" src="/TTQ/assets/app.2cebdad9.js" defer></script>
  </body>
</html>
